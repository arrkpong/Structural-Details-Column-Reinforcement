<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural Detail - Column Reinforcement</title>
    <style>
        :root {
            --blueprint-bg: #0a244d;
            --blueprint-grid: #1c3b6b;
            --drawing-white: #ffffff;
            --drawing-yellow: #ffeb3b;
            --sidebar-bg: #f4f4f4;
            --sidebar-text: #333;
        }
        
        body {
            background-color: var(--blueprint-bg);
            margin: 0;
            padding: 0;
            font-family: 'Courier New', Courier, monospace; /* Blueprint-style font */
            color: var(--drawing-white);
            height: 100vh;
            display: flex; /* Use Flexbox for main layout */
            overflow: hidden;
        }

        /* --- Sidebar Styles --- */
        .sidebar {
            position: fixed;
            top: 0;
            left: -400px; /* Hidden completely (width 350 + padding 40 = 390) */
            width: 350px;
            height: 100vh;
            background-color: var(--sidebar-bg);
            color: var(--sidebar-text);
            padding: 20px;
            padding-top: 60px; /* Space for toggle button */
            overflow-y: auto;
            box-shadow: none; /* No shadow when hidden */
            display: flex;
            flex-direction: column;
            gap: 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            z-index: 100;
            transition: left 0.3s ease, box-shadow 0.3s ease;
        }
        .sidebar.open {
            left: 0;
            box-shadow: 2px 0 15px rgba(0,0,0,0.4);
        }

        .sidebar h2 { margin-top: 0; border-bottom: 2px solid #ddd; padding-bottom: 10px; font-size: 1.2rem; }
        .form-group { display: flex; flex-direction: column; gap: 5px; margin-bottom: 10px; }
        .form-group label { font-size: 0.9rem; font-weight: 600; }
        .form-group input, .form-group select { 
            padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 0.9rem; 
        }
        .form-row { display: flex; gap: 10px; flex-wrap: wrap; }
        .form-row .form-group { flex: 1; min-width: 140px; }
        
        .section-header {
            background: #e0e0e0;
            padding: 5px 10px;
            font-weight: bold;
            margin: 10px -20px 5px -20px; /* Full width edge-to-edge */
        }

        /* --- Drawing Area Styles --- */
        .drawing-container {
            flex: 1; /* Take remaining space */
            position: relative;
            background-image: 
                linear-gradient(var(--blueprint-grid) 1px, transparent 1px),
                linear-gradient(90deg, var(--blueprint-grid) 1px, transparent 1px);
            background-size: 40px 40px; /* Grid size */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .viewport {
            width: 95%;
            height: 95%;
        }

        svg {
            width: 100%;
            height: 100%;
            /* border: 1px solid rgba(255, 255, 255, 0.2); Debug border */
        }

        /* SVG Elements Styling */
        .concrete-outline { fill: none; stroke: white; stroke-width: 2; }
        .stirrup { fill: none; stroke: var(--drawing-yellow); stroke-width: 2; }
        .main-bar { fill: white; stroke: none; }
        .dim-line { stroke: white; stroke-width: 0.5; }
        .label-text { fill: white; font-size: 14px; font-weight: bold; }
        .sub-label { fill: #aaaaaa; font-size: 12px; }
        .view-title { font-size: 20px; font-weight: bold; text-decoration: underline; fill: var(--drawing-white); }

        .title-block-container {
            position: absolute;
            bottom: 20px;
            right: 40px;
            z-index: 10;
        }

        .title-block {
            border: 2px solid white;
            padding: 15px;
            background: rgba(10, 36, 77, 0.9);
            width: 300px;
            font-size: 12px;
        }
        
        .tb-row { display: flex; margin-bottom: 5px; }
        .tb-label { font-weight: bold; width: 80px; flex-shrink: 0; }
        .tb-value { flex-grow: 1; }
        .tb-project { font-size: 14px; font-weight: bold; color: var(--drawing-yellow); margin-bottom: 10px; border-bottom: 1px solid white; padding-bottom: 5px; }

        /* Mobile title block hidden by default (shown via media query) */
        .title-block-mobile {
            display: none;
        }

        /* Export Button Styles */
        .export-btn {
            width: 100%;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .export-btn.svg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .export-btn.svg:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46a0 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Menu Toggle Button (visible on all screens) */
        .menu-toggle {
            display: block;
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            background: var(--sidebar-bg);
            border: none;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .menu-toggle span {
            display: block;
            width: 24px;
            height: 3px;
            background: var(--sidebar-text);
            margin: 5px 0;
            border-radius: 2px;
            transition: all 0.3s ease;
        }
        .menu-toggle.active span:nth-child(1) {
            transform: rotate(45deg) translate(6px, 6px);
        }
        .menu-toggle.active span:nth-child(2) {
            opacity: 0;
        }
        .menu-toggle.active span:nth-child(3) {
            transform: rotate(-45deg) translate(6px, -6px);
        }

        /* Sidebar Overlay for Mobile */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 99;
        }
        .sidebar-overlay.active {
            display: block;
        }

        /* --- Responsive Breakpoints --- */

        /* Tablet: max-width 1024px */
        @media (max-width: 1024px) {
            .sidebar {
                width: 300px;
                padding: 15px;
            }
            .title-block {
                width: 260px;
                font-size: 11px;
            }
            .title-block-container {
                right: 20px;
                bottom: 15px;
            }
        }

        /* Mobile: max-width 768px */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                overflow: auto;
            }
            
            .sidebar {
                width: 300px;
                left: -350px; /* width 300 + padding ~40 */
            }
            .sidebar.open {
                left: 0;
            }
            
            .sidebar-overlay.active {
                display: block;
            }
            
            .drawing-container {
                width: 100%;
                min-height: 60vh;
            }
            
            .viewport {
                width: 100%;
                height: 100%;
            }
            
            .title-block-container.title-block-desktop {
                display: none; /* Hide desktop version on mobile */
            }
            .title-block-container.title-block-mobile {
                display: block !important; /* Show mobile version */
                position: static !important; /* In normal flow, not fixed/absolute */
                left: 0 !important;
                right: 0 !important;
                transform: none !important;
                width: 100%;
                padding: 15px;
                margin: 0;
                background: rgba(10, 36, 77, 0.98);
                border-top: 2px solid white;
                box-sizing: border-box;
            }
            .title-block-mobile .title-block {
                width: 100%;
                max-width: none;
                margin: 0;
                font-size: 12px;
                padding: 0;
                border: none;
                background: transparent;
            }
            .title-block-mobile .tb-project {
                font-size: 13px;
                margin-bottom: 8px;
                word-wrap: break-word;
            }
            .title-block-mobile .tb-row {
                margin-bottom: 4px;
            }
            .title-block-mobile .tb-label {
                width: auto;
                min-width: 90px;
                white-space: nowrap;
            }
            
            .form-row {
                flex-direction: column;
                gap: 0;
            }
        }

        /* Small Mobile: max-width 480px */
        @media (max-width: 480px) {
            .sidebar {
                width: 280px;
                left: -320px; /* width 280 + padding ~30 */
                padding: 10px;
                padding-top: 55px;
            }
            
            .sidebar h2 {
                font-size: 1rem;
            }
            
            .section-header {
                margin: 8px -10px 5px -10px;
                padding: 4px 8px;
                font-size: 0.85rem;
            }
            
            .form-group label {
                font-size: 0.8rem;
            }
            .form-group input, .form-group select {
                padding: 6px;
                font-size: 0.85rem;
            }
            
            .export-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .title-block {
                font-size: 10px;
                padding: 10px;
            }
            .tb-label {
                width: 70px;
            }
        }

        /* Landscape Mobile: hide title block when height is too small */
        @media (max-height: 500px) {
            .title-block-container.title-block-desktop {
                display: none;
            }
            
            /* Single column layout for sidebar on landscape mobile */
            .form-row {
                flex-direction: column;
                gap: 0;
            }
            
            /* Make sidebar narrower for landscape mobile */
            .sidebar {
                width: 300px;
                left: -350px; /* width 300 + padding ~40 */
            }
            
            .drawing-container {
                margin-left: 0;
                width: 100%;
                height: 100%;
            }
        }

        /* --- Zoom Controls --- */
        .zoom-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 50;
        }
        .zoom-btn, .fullscreen-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .zoom-btn:hover, .fullscreen-btn:hover {
            background: white;
            transform: scale(1.1);
        }
        .fullscreen-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .zoom-level {
            text-align: center;
            font-size: 12px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        /* Fullscreen mode */
        .drawing-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 200;
            background: var(--blueprint-bg);
        }
        .drawing-container.fullscreen .viewport {
            width: 100%;
            height: 100%;
        }
        .drawing-container.fullscreen .title-block-container {
            display: none;
        }
        .drawing-container.fullscreen + .zoom-controls {
            z-index: 250;
        }

        /* Mobile zoom controls always visible */
        @media (max-width: 768px) {
            .zoom-controls {
                bottom: 15px;
                right: 15px;
            }
            .zoom-btn, .fullscreen-btn {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

    </style>
</head>
<body>

    <!-- Mobile Menu Toggle Button -->
    <button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">
        <span></span>
        <span></span>
        <span></span>
    </button>
    
    <!-- Sidebar Overlay (for closing sidebar on mobile) -->
    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <!-- Sidebar Control Panel -->
    <div class="sidebar" id="sidebar">
        <h2>Panel Control</h2>
        
        <div class="section-header">Title</div>
        <div class="form-group">
            <label>Project Name</label>
            <input type="text" id="inp-project" value="CIVIL PARK INTERNATIONAL">
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Dwg Title</label>
                <input type="text" id="inp-title-val" value="COLUMN C1">
            </div>
            <div class="form-group">
                <label>Date</label>
                <input type="text" id="inp-date-val" value="18/12/2025">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Drawn By</label>
                <input type="text" id="inp-drawn-val" value="arrkpong jerosiri">
            </div>
            <div class="form-group">
                <label>Scale</label>
                <input type="text" id="inp-scale-val" value="N.T.S.">
            </div>
        </div>
        <div class="form-group">
            <label>Note Suffix</label>
            <input type="text" id="inp-note-val" value="ARRANGED ALONG BOUNDARY.">
        </div>

        <div class="section-header">Dimensions (mm)</div>
        <div class="form-row">
            <div class="form-group">
                <label>Width (Bx)</label>
                <input type="number" id="inp-width" value="600" step="50">
            </div>
            <div class="form-group">
                <label>Depth (By)</label>
                <input type="number" id="inp-depth" value="600" step="50">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Column Height</label>
                <input type="number" id="inp-height" value="5000" step="100">
            </div>
            <div class="form-group">
                <label>Confinement Zone (lo)</label>
                <input type="number" id="inp-zone-height" value="1000" step="100">
            </div>
        </div>
        <div class="form-group">
            <label>Cover</label>
            <input type="number" id="inp-cover" value="40">
        </div>

        <div class="section-header">Materials</div>
        <div class="form-row">
            <div class="form-group">
                <label>Concrete (fc')</label>
                <input type="text" id="inp-concrete" value="28 MPa">
            </div>
            <div class="form-group">
                <label>Steel (fy)</label>
                <input type="text" id="inp-steel" value="SD40">
            </div>
        </div>

        <div class="section-header">Longitudinal Bars</div>
        <div class="form-row">
            <div class="form-group">
                <label>Info</label>
                <input type="text" id="inp-main-size" value="DB25">
            </div>
            <div class="form-group">
                <label>Total Count</label>
                <input type="number" id="inp-main-count" value="16" readonly title="Calculated from X/Y">
            </div>
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Bars X-Dir</label>
                <input type="number" id="inp-nx" value="5" min="2">
            </div>
            <div class="form-group">
                <label>Bars Y-Dir</label>
                <input type="number" id="inp-ny" value="5" min="2">
            </div>
        </div>

        <div class="section-header">Transverse Reinforcement</div>
        <div class="form-group">
            <label>Size</label>
            <input type="text" id="inp-tie-size" value="DB10">
        </div>
        <div class="form-row">
            <div class="form-group">
                <label>Spacing @ lo</label>
                <input type="number" id="inp-s-zone" value="75">
            </div>
            <div class="form-group">
                <label>Spacing @ Center</label>
                <input type="number" id="inp-s-mid" value="200">
            </div>
        </div>

        <div class="section-header">Export</div>
        <button class="export-btn svg" onclick="exportSVG()">
            Export SVG
        </button>
    </div>

    <!-- Drawing Area -->
    <div class="drawing-container">
        <div class="viewport">
            <svg id="main-svg" viewBox="-100 -50 1400 700" preserveAspectRatio="xMidYMid meet">
                <!-- Content will be generated by JS -->
            </svg>
        </div>

        <!-- Title Block (shown inside drawing-container for desktop) -->
        <div class="title-block-container title-block-desktop">
            <div class="title-block">
                <div class="tb-project"><span id="lbl-project">PROJECT</span>: <span id="tb-project">...</span></div>
                <div class="tb-row">
                    <span class="tb-label"><span id="lbl-title">DWG TITLE</span>:</span>
                    <span class="tb-value" id="tb-title">...</span>
                </div>
                <div class="tb-row">
                    <span class="tb-label">DATE:</span>
                    <span class="tb-value" id="tb-date">...</span>
                </div>
                <div class="tb-row">
                    <span class="tb-label"><span id="lbl-drawn">DRAWN BY</span>:</span>
                    <span class="tb-value" id="tb-drawn-val">...</span>
                </div>
                <div class="tb-row">
                    <span class="tb-label">SCALE:</span>
                    <span class="tb-value" id="tb-scale">...</span>
                </div>
                <div class="tb-row">
                    <span class="tb-label"><span id="lbl-note">NOTE</span>:</span>
                    <span class="tb-value" id="tb-note">...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Title Block for Mobile (outside drawing-container, in scroll flow) -->
    <div class="title-block-container title-block-mobile">
        <div class="title-block">
            <div class="tb-project">PROJECT: <span id="tb-project-mobile">...</span></div>
            <div class="tb-row">
                <span class="tb-label">DWG TITLE:</span>
                <span class="tb-value" id="tb-title-mobile">...</span>
            </div>
            <div class="tb-row">
                <span class="tb-label">DATE:</span>
                <span class="tb-value" id="tb-date-mobile">...</span>
            </div>
            <div class="tb-row">
                <span class="tb-label">DRAWN BY:</span>
                <span class="tb-value" id="tb-drawn-mobile">...</span>
            </div>
            <div class="tb-row">
                <span class="tb-label">SCALE:</span>
                <span class="tb-value" id="tb-scale-mobile">...</span>
            </div>
            <div class="tb-row">
                <span class="tb-label">NOTE:</span>
                <span class="tb-value" id="tb-note-mobile">...</span>
            </div>
        </div>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls" id="zoomControls">
        <button class="fullscreen-btn" id="fullscreenBtn" title="Fullscreen">⛶</button>
        <button class="zoom-btn" id="zoomInBtn" title="Zoom In">+</button>
        <div class="zoom-level" id="zoomLevel">100%</div>
        <button class="zoom-btn" id="zoomOutBtn" title="Zoom Out">−</button>
        <button class="zoom-btn" id="zoomResetBtn" title="Reset" style="font-size: 14px;">⟲</button>
    </div>

    <script>
        // --- Configuration & State ---
        const svg = document.getElementById('main-svg');
        const state = {
            project: '',
            width: 0, depth: 0, height: 0, zoneHeight: 0, cover: 0,
            concrete: '', steel: '',
            mainSize: '', nx: 0, ny: 0,
            tieSize: '', sZone: 0, sMid: 0
        };

        // --- DOM Elements ---
        const inputs = {
            project: document.getElementById('inp-project'),
            width: document.getElementById('inp-width'),
            depth: document.getElementById('inp-depth'),
            height: document.getElementById('inp-height'),
            zoneHeight: document.getElementById('inp-zone-height'),
            cover: document.getElementById('inp-cover'),
            concrete: document.getElementById('inp-concrete'),
            steel: document.getElementById('inp-steel'),
            mainSize: document.getElementById('inp-main-size'),
            nx: document.getElementById('inp-nx'),
            ny: document.getElementById('inp-ny'),
            tieSize: document.getElementById('inp-tie-size'),
            sZone: document.getElementById('inp-s-zone'),
            sMid: document.getElementById('inp-s-mid'),
            mainCountDisplay: document.getElementById('inp-main-count'),
            // Inputs for Values
            titleVal: document.getElementById('inp-title-val'),
            dateVal: document.getElementById('inp-date-val'),
            drawnVal: document.getElementById('inp-drawn-val'),
            scaleVal: document.getElementById('inp-scale-val'),
            noteVal: document.getElementById('inp-note-val')
        };

        // --- Initialization ---
        function init() {
            // Attach event listeners for inputs
            Object.values(inputs).forEach(inp => {
                if(inp) inp.addEventListener('input', updateDrawing);
            });
            
            // Mobile menu toggle setup
            const menuToggle = document.getElementById('menuToggle');
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            
            function toggleSidebar() {
                menuToggle.classList.toggle('active');
                sidebar.classList.toggle('open');
                overlay.classList.toggle('active');
            }
            
            function closeSidebar() {
                menuToggle.classList.remove('active');
                sidebar.classList.remove('open');
                overlay.classList.remove('active');
            }
            
            if (menuToggle) {
                menuToggle.addEventListener('click', toggleSidebar);
            }
            if (overlay) {
                overlay.addEventListener('click', closeSidebar);
            }
            
            // Redraw on window resize for orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                // Debounce redraw for orientation change
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateDrawing();
                }, 200);
            });
            
            // --- Zoom and Fullscreen Setup ---
            const drawingContainer = document.querySelector('.drawing-container');
            const zoomInBtn = document.getElementById('zoomInBtn');
            const zoomOutBtn = document.getElementById('zoomOutBtn');
            const zoomResetBtn = document.getElementById('zoomResetBtn');
            const zoomLevelDisplay = document.getElementById('zoomLevel');
            const fullscreenBtn = document.getElementById('fullscreenBtn');
            
            // Original viewBox values
            const origViewBox = { x: -100, y: -50, w: 1400, h: 700 };
            let currentZoom = 1;
            let panX = 0; // Pan offset X
            let panY = 0; // Pan offset Y
            const minZoom = 0.5;
            const maxZoom = 3;
            const zoomStep = 0.25;
            
            function updateViewBox() {
                // Calculate new viewBox based on zoom (smaller viewBox = zoomed in)
                const newW = origViewBox.w / currentZoom;
                const newH = origViewBox.h / currentZoom;
                // Center the view + pan offset
                const newX = origViewBox.x + (origViewBox.w - newW) / 2 + panX;
                const newY = origViewBox.y + (origViewBox.h - newH) / 2 + panY;
                svg.setAttribute('viewBox', `${newX} ${newY} ${newW} ${newH}`);
                zoomLevelDisplay.textContent = `${Math.round(currentZoom * 100)}%`;
            }
            
            function zoomIn() {
                if (currentZoom < maxZoom) {
                    currentZoom = Math.min(maxZoom, currentZoom + zoomStep);
                    updateViewBox();
                }
            }
            
            function zoomOut() {
                if (currentZoom > minZoom) {
                    currentZoom = Math.max(minZoom, currentZoom - zoomStep);
                    updateViewBox();
                }
            }
            
            function zoomReset() {
                currentZoom = 1;
                panX = 0;
                panY = 0;
                updateViewBox();
            }
            
            function toggleFullscreen() {
                drawingContainer.classList.toggle('fullscreen');
                if (drawingContainer.classList.contains('fullscreen')) {
                    fullscreenBtn.textContent = '✕';
                    fullscreenBtn.title = 'Exit Fullscreen';
                } else {
                    fullscreenBtn.textContent = '⛶';
                    fullscreenBtn.title = 'Fullscreen';
                }
            }
            
            // Event listeners for zoom controls
            if (zoomInBtn) zoomInBtn.addEventListener('click', zoomIn);
            if (zoomOutBtn) zoomOutBtn.addEventListener('click', zoomOut);
            if (zoomResetBtn) zoomResetBtn.addEventListener('click', zoomReset);
            if (fullscreenBtn) fullscreenBtn.addEventListener('click', toggleFullscreen);
            
            // --- Pan (Drag) Functionality ---
            let isPanning = false;
            let startX = 0;
            let startY = 0;
            let startPanX = 0;
            let startPanY = 0;
            
            function startPan(e) {
                if (e.button !== undefined && e.button !== 0) return; // Only left mouse button
                isPanning = true;
                const pos = e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
                startX = pos.x;
                startY = pos.y;
                startPanX = panX;
                startPanY = panY;
                svg.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function doPan(e) {
                if (!isPanning) return;
                const pos = e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
                const dx = pos.x - startX;
                const dy = pos.y - startY;
                
                // Convert screen pixels to SVG units (depends on current viewBox size vs element size)
                const rect = svg.getBoundingClientRect();
                const viewBoxW = origViewBox.w / currentZoom;
                const viewBoxH = origViewBox.h / currentZoom;
                const scaleX = viewBoxW / rect.width;
                const scaleY = viewBoxH / rect.height;
                
                panX = startPanX - dx * scaleX;
                panY = startPanY - dy * scaleY;
                updateViewBox();
                e.preventDefault();
            }
            
            function endPan(e) {
                isPanning = false;
                svg.style.cursor = 'grab';
            }
            
            // Mouse events
            svg.addEventListener('mousedown', startPan);
            svg.addEventListener('mousemove', doPan);
            svg.addEventListener('mouseup', endPan);
            svg.addEventListener('mouseleave', endPan);
            
            // Touch events
            svg.addEventListener('touchstart', startPan, { passive: false });
            svg.addEventListener('touchmove', doPan, { passive: false });
            svg.addEventListener('touchend', endPan);
            svg.addEventListener('touchcancel', endPan);
            
            // Mouse wheel zoom
            svg.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY < 0) {
                    // Scroll up = zoom in
                    zoomIn();
                } else {
                    // Scroll down = zoom out
                    zoomOut();
                }
            }, { passive: false });

            // Set initial cursor
            svg.style.cursor = 'grab';
            
            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && drawingContainer.classList.contains('fullscreen')) {
                    toggleFullscreen();
                }
                if (e.key === '+' || e.key === '=') zoomIn();
                if (e.key === '-') zoomOut();
                if (e.key === '0') zoomReset();
            });
            
            // Set current date in DD/MM/YYYY format
            const today = new Date();
            const day = String(today.getDate()).padStart(2, '0');
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const year = today.getFullYear();
            const dateInput = document.getElementById('inp-date-val');
            if (dateInput) dateInput.value = `${day}/${month}/${year}`;
            
            updateDrawing();
        }

        // --- Main Update Function ---
        function updateDrawing() {
            try {
                // 1. Read Inputs with Fallbacks and validation
                state.project = inputs.project ? inputs.project.value : "";
                state.width = Math.max(100, (inputs.width ? parseFloat(inputs.width.value) : 600) || 600);
                state.depth = Math.max(100, (inputs.depth ? parseFloat(inputs.depth.value) : 600) || 600);
                state.height = Math.max(1000, (inputs.height ? parseFloat(inputs.height.value) : 5000) || 5000);
                state.zoneHeight = Math.max(100, (inputs.zoneHeight ? parseFloat(inputs.zoneHeight.value) : 1000) || 1000);
                state.cover = Math.max(20, (inputs.cover ? parseFloat(inputs.cover.value) : 40) || 40);
                state.mainSize = inputs.mainSize ? inputs.mainSize.value : "DB25";
                state.nx = Math.max(2, (inputs.nx ? parseInt(inputs.nx.value) : 2) || 2);
                state.ny = Math.max(2, (inputs.ny ? parseInt(inputs.ny.value) : 2) || 2);
                state.tieSize = inputs.tieSize ? inputs.tieSize.value : "DB10";
                state.sZone = Math.max(50, (inputs.sZone ? parseFloat(inputs.sZone.value) : 75) || 75);
                state.sMid = Math.max(75, (inputs.sMid ? parseFloat(inputs.sMid.value) : 200) || 200);

                // Update Calculated Fields
                const totalBars = 2 * state.nx + 2 * (state.ny - 2); 
                if(inputs.mainCountDisplay) inputs.mainCountDisplay.value = totalBars;

                // 2. Update Title Block (Values)
                const valTitle = inputs.titleVal ? inputs.titleVal.value : "";
                const valDate = inputs.dateVal ? inputs.dateVal.value : "";
                const valDrawn = inputs.drawnVal ? inputs.drawnVal.value : "";
                const valScale = inputs.scaleVal ? inputs.scaleVal.value : "";
                const valNote = inputs.noteVal ? inputs.noteVal.value : "";

                const elTbProject = document.getElementById('tb-project');
                const elTbTitle = document.getElementById('tb-title');
                const elTbDate = document.getElementById('tb-date');
                const elTbDrawn = document.getElementById('tb-drawn-val');
                const elTbScale = document.getElementById('tb-scale');
                const elTbNote = document.getElementById('tb-note');

                if (elTbProject) elTbProject.textContent = state.project.toUpperCase();
                if (elTbTitle) elTbTitle.textContent = valTitle.toUpperCase();
                if (elTbDate) elTbDate.textContent = valDate;
                if (elTbDrawn) elTbDrawn.textContent = valDrawn;
                if (elTbScale) elTbScale.textContent = valScale;
                if (elTbNote) elTbNote.textContent = `${totalBars}-${state.mainSize} ${valNote}`;

                // Update mobile title block elements (same data, different IDs)
                const mobileIds = {
                    'tb-project-mobile': state.project.toUpperCase(),
                    'tb-title-mobile': valTitle.toUpperCase(),
                    'tb-date-mobile': valDate,
                    'tb-drawn-mobile': valDrawn,
                    'tb-scale-mobile': valScale,
                    'tb-note-mobile': `${totalBars}-${state.mainSize} ${valNote}`
                };
                Object.entries(mobileIds).forEach(([id, value]) => {
                    const el = document.getElementById(id);
                    if (el) el.textContent = value;
                });

                // 3. Clear SVG
                svg.innerHTML = '';
                
                // 4. Check orientation for layout
                const isMobilePortrait = window.innerWidth < 768 && window.innerWidth < window.innerHeight;
                
                // Adjust viewBox for mobile portrait (vertical stacking)
                if (isMobilePortrait) {
                    // Portrait: taller viewBox for vertical stacking with extra space for titles
                    svg.setAttribute('viewBox', '-50 -50 700 1350');
                } else {
                    // Landscape/Desktop: horizontal layout
                    svg.setAttribute('viewBox', '-100 -50 1400 700');
                }
                
                // 5. Add Defs
                addDefs();

                // 6. Draw Views
                drawSectionView(isMobilePortrait);
                drawElevationView(isMobilePortrait);
            } catch (err) {
                console.error("Error updating drawing:", err);
            }
        }


        function addDefs() {
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            defs.innerHTML = `
                <marker id="dot" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="5" markerHeight="5">
                    <circle cx="5" cy="5" r="3" fill="#00FFFF"/>
                </marker>
                <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M0,0 L10,5 L0,10 z" fill="#00FFFF"/>
                </marker>
            `;
            svg.appendChild(defs);
        }

        // --- Drawing Helpers ---
        function createEl(type, attrs) {
            const el = document.createElementNS("http://www.w3.org/2000/svg", type);
            for (const [k, v] of Object.entries(attrs)) el.setAttribute(k, v);
            return el;
        }

        function drawSectionView(isMobilePortrait = false) {
            // Center on mobile portrait: shift X to center in viewBox width 700
            const translateX = isMobilePortrait ? 100 : 0;
            const group = createEl('g', { id: 'section-view', transform: `translate(${translateX}, 0)` });
            
            // Scale Factor: let's map input dimensions to drawing units
            // Assuming 1 unit = 1 pixel for simplicity in this ViewBox
            // Center the column at (200, 200) locally
            const startX = 50; 
            const startY = 50;
            // Scale: 600mm -> 300px => ratio = 0.5
            const scale = 0.5;
            const w = state.width * scale;
            const h = state.depth * scale;
            const cvr = state.cover * scale; // cover in dwg units

            // 1. Concrete Outline
            const concrete = createEl('rect', {
                x: startX, y: startY, width: w, height: h,
                class: 'concrete-outline'
            });
            group.appendChild(concrete);

            // 2. Main Stirrup with 135° Hooks (per seismic detailing standards)
            // Inset by cover
            const stX = startX + cvr;
            const stY = startY + cvr;
            const stW = w - 2*cvr;
            const stH = h - 2*cvr;
            const r = 8; // corner radius for bending

            // Hook parameters (135° hook = 10d extension + bend)
            const hookLen = 25; // Visual hook length
            const hookAngle = 135 * Math.PI / 180; // 135 degrees
            
            // Build stirrup path: Start at top-left after hook, go clockwise
            // Top-Left Hook (135° pointing inward-down)
            const tlHookEndX = stX + Math.cos(hookAngle - Math.PI) * hookLen;
            const tlHookEndY = stY + Math.sin(hookAngle - Math.PI) * hookLen;
            
            let d = `M ${tlHookEndX} ${tlHookEndY}`;  // Hook end
            d += ` L ${stX} ${stY}`;  // Hook to corner
            d += ` H ${stX+stW-r}`;  // Top edge
            d += ` A ${r} ${r} 0 0 1 ${stX+stW} ${stY+r}`;  // TR corner arc
            d += ` V ${stY+stH-r}`;  // Right edge
            d += ` A ${r} ${r} 0 0 1 ${stX+stW-r} ${stY+stH}`;  // BR corner arc
            
            // Bottom-Right Hook (135° pointing inward-up)
            const brHookEndX = stX+stW + Math.cos(-hookAngle) * hookLen;
            const brHookEndY = stY+stH + Math.sin(-hookAngle) * hookLen;
            d += ` L ${brHookEndX} ${brHookEndY}`;  // Hook extension
            d += ` M ${stX+stW-r} ${stY+stH}`;  // Return to path
            
            d += ` H ${stX+r}`;  // Bottom edge
            d += ` A ${r} ${r} 0 0 1 ${stX} ${stY+stH-r}`;  // BL corner arc
            d += ` V ${stY+r}`;  // Left edge
            d += ` A ${r} ${r} 0 0 1 ${stX+r} ${stY}`;  // TL corner arc
            d += ` H ${stX}`;  // Close to hook start

            const stirrup = createEl('path', {
                d: d,
                fill: 'none', stroke: '#ffeb3b', 'stroke-width': 2
            });
            group.appendChild(stirrup);
            
            // Hook annotation labels with calculated lengths
            // Parse tie diameter (e.g., "DB10" -> 10)
            const tieDia = parseInt(state.tieSize.replace(/\D/g, '')) || 10;
            const hookLengthMm = 6 * tieDia; // 6d hook extension
            const bendRadius = 4 * tieDia;   // 4d bend radius for bars ≤ DB16
            
            const hookLabel = createEl('text', { 
                x: tlHookEndX - 5, y: tlHookEndY - 5, 
                'text-anchor': 'end', class: 'sub-label', fill: '#ffeb3b' 
            });
            hookLabel.textContent = `135° HOOK (6d=${hookLengthMm}mm)`;
            group.appendChild(hookLabel);
            
            // Bend radius label (at corner)
            const bendLabel = createEl('text', { 
                x: stX + stW + 15, y: stY + 15, 
                'text-anchor': 'start', class: 'sub-label', fill: '#ffeb3b' 
            });
            bendLabel.textContent = `r=${bendRadius}mm (4d)`;
            group.appendChild(bendLabel);

            // 3. Main Bars
            // Calculate positions
            // X-spacing: (stW) / (nx - 1)
            // Y-spacing: (stH) / (ny - 1)
            const sx = stW / (state.nx - 1);
            const sy = stH / (state.ny - 1);
            
            const barGroup = createEl('g', { id: 'main-bars' });
            
            // Draw Top and Bottom rows
            for(let i=0; i<state.nx; i++) {
                const cx = stX + i*sx;
                // Top
                barGroup.appendChild(createEl('circle', { cx: cx, cy: stY, r: 8, class: 'main-bar' }));
                // Bottom
                barGroup.appendChild(createEl('circle', { cx: cx, cy: stY+stH, r: 8, class: 'main-bar' }));
            }
            // Draw Side rows (exclude corners)
            for(let j=1; j<state.ny-1; j++) {
                const cy = stY + j*sy;
                // Left
                barGroup.appendChild(createEl('circle', { cx: stX, cy: cy, r: 8, class: 'main-bar' }));
                // Right
                barGroup.appendChild(createEl('circle', { cx: stX+stW, cy: cy, r: 8, class: 'main-bar' }));
            }
            group.appendChild(barGroup);
            
            // Clear Spacing Annotation (between first two bars on top row)
            // Clear spacing = center-to-center spacing - bar diameter
            const mainBarDia = parseInt(state.mainSize.replace(/\D/g, '')) || 25;
            const actualSpacing = (stW / (state.nx - 1)) * (state.width / w); // Scale to actual mm
            const clearSpacing = Math.round(actualSpacing - mainBarDia);
            
            if (state.nx >= 3) {
                // Draw spacing dimension line between bar 1 and bar 2
                const bar1X = stX + sx;
                const bar2X = stX + 2 * sx;
                const dimY = stY - 25;
                
                // Dimension line
                group.appendChild(createEl('line', { 
                    x1: bar1X, y1: dimY, x2: bar2X, y2: dimY, 
                    stroke: '#aaa', 'stroke-width': 0.5 
                }));
                // Tick marks
                group.appendChild(createEl('line', { x1: bar1X, y1: dimY-5, x2: bar1X, y2: dimY+5, stroke: '#aaa', 'stroke-width': 0.5 }));
                group.appendChild(createEl('line', { x1: bar2X, y1: dimY-5, x2: bar2X, y2: dimY+5, stroke: '#aaa', 'stroke-width': 0.5 }));
                
                // Clear spacing label
                const spacingLabel = createEl('text', { 
                    x: (bar1X + bar2X) / 2, y: dimY - 5, 
                    'text-anchor': 'middle', class: 'sub-label', fill: '#aaa' 
                });
                spacingLabel.textContent = `CLEAR ${clearSpacing}mm`;
                group.appendChild(spacingLabel);
            }
            
            // 4. Cross Ties (Simplified Logic: Connect opposing bars if > 2x2)
            // Vertical Ties (connect top-bottom) for internal cols
            const tieGroup = createEl('g', { id: 'cross-ties', fill: 'none', stroke: '#ffeb3b', 'stroke-width': 2 });
            
            // Vertical Crossties (skip outer cols 0 and nx-1)
            for (let i = 1; i < state.nx - 1; i++) {
                const cx = stX + i * sx;
                const topY = stY + 10;
                const botY = stY + stH - 10;
                // Draw line with hooks (S-hook shape)
                const path = `M ${cx - 10} ${topY + 10} L ${cx} ${topY} V ${botY} L ${cx + 10} ${botY - 10}`;
                tieGroup.appendChild(createEl('path', { d: path }));
            }
            
            // Horizontal Crossties (skip outer rows 0 and ny-1)
            for (let j = 1; j < state.ny - 1; j++) {
                const cy = stY + j * sy;
                const leftX = stX + 10;
                const rightX = stX + stW - 10;
                const path = `M ${leftX + 10} ${cy - 10} L ${leftX} ${cy} H ${rightX} L ${rightX - 10} ${cy + 10}`;
                tieGroup.appendChild(createEl('path', { d: path }));
            }
            group.appendChild(tieGroup);

            // 5. Labels & Dimensions (Dynamic positions)
            // Top Dimension - Width
            group.appendChild(createEl('line', { x1: startX, y1: startY-20, x2: startX+w, y2: startY-20, class: 'dim-line' })); // Main line
            group.appendChild(createEl('line', { x1: startX, y1: startY-25, x2: startX, y2: startY-15, class: 'dim-line' })); // L tick
            group.appendChild(createEl('line', { x1: startX+w, y1: startY-25, x2: startX+w, y2: startY-15, class: 'dim-line' })); // R tick
            // Text center
            const textW = createEl('text', { x: startX + w/2, y: startY-30, 'text-anchor': 'middle', class: 'label-text' });
            textW.textContent = state.width;
            group.appendChild(textW);

            // Side Dimension - Depth
            group.appendChild(createEl('line', { x1: startX-20, y1: startY, x2: startX-20, y2: startY+h, class: 'dim-line' })); 
            group.appendChild(createEl('line', { x1: startX-25, y1: startY, x2: startX-15, y2: startY, class: 'dim-line' })); 
            group.appendChild(createEl('line', { x1: startX-25, y1: startY+h, x2: startX-15, y2: startY+h, class: 'dim-line' })); 
            const textH = createEl('text', { 
                x: startX-30, y: startY + h/2, 'text-anchor': 'middle', 
                transform: `rotate(-90, ${startX-30}, ${startY + h/2})`, class: 'label-text' 
            });
            textH.textContent = state.depth;
            group.appendChild(textH);

            // Leader Lines & Text
            // Dog-leg style: angled line from element + horizontal line for text (engineering standard)
            
            // Rebar Label (Main Bars) - pointing to top-right bar
            const barPointX = stX + stW;  // Right side bar X
            const barPointY = stY;        // Top bar Y
            const barMidX = startX + w + 40;
            const barMidY = startY - 20;
            const barEndX = startX + w + 100;
            
            // Angled line from bar to midpoint
            group.appendChild(createEl('path', { 
                d: `M ${barPointX} ${barPointY} L ${barMidX} ${barMidY}`, 
                stroke:'#00FFFF', 'stroke-width':0.5, 'marker-start':'url(#arrow)' 
            }));
            // Horizontal line from midpoint
            group.appendChild(createEl('line', { 
                x1: barMidX, y1: barMidY, x2: barEndX, y2: barMidY, 
                stroke:'#00FFFF', 'stroke-width':0.5 
            }));
            const labelRebar = createEl('text', { x: barEndX + 5, y: barMidY + 5, class: 'label-text' });
            const total = (2*state.nx + 2*(state.ny-2));
            labelRebar.textContent = `${total}-${state.mainSize}`;
            group.appendChild(labelRebar);
            const subLabelRebar = createEl('text', { x: barEndX + 5, y: barMidY + 20, class: 'sub-label' });
            subLabelRebar.textContent = "Longitudinal Bars";
            group.appendChild(subLabelRebar);

            // Hoops Label - pointing to stirrup line (between bars, not at bar position)
            // Calculate position between first and second bar on right edge
            const barSpacingY = (stH - 2 * r) / (state.ny - 1);
            // Point to stirrup line midway between first and second bar
            const tiePointX = stX + stW + r + 2;  // Just outside the stirrup line
            const tiePointY = stY + r + barSpacingY / 2;  // Midway between first two bars
            const tieMidX = startX + w + 40;
            const tieMidY = startY + h/2 - 30;
            const tieEndX = startX + w + 100;
            
            group.appendChild(createEl('path', { 
                d: `M ${tiePointX} ${tiePointY} L ${tieMidX} ${tieMidY}`, 
                stroke:'#00FFFF', 'stroke-width':0.5, 'marker-start':'url(#arrow)' 
            }));
            group.appendChild(createEl('line', { 
                x1: tieMidX, y1: tieMidY, x2: tieEndX, y2: tieMidY, 
                stroke:'#00FFFF', 'stroke-width':0.5 
            }));
            const labelTie = createEl('text', { x: tieEndX + 5, y: tieMidY + 5, class: 'label-text' });
            labelTie.textContent = state.tieSize;
            group.appendChild(labelTie);
            const subLabelTie = createEl('text', { x: tieEndX + 5, y: tieMidY + 20, class: 'sub-label' });
            subLabelTie.textContent = "Hoops";
            group.appendChild(subLabelTie);

            // Crossties Label - pointing to internal ties (if present)
            if (state.nx > 2 || state.ny > 2) {
                const crossPointX = stX + stW/2;  // Center of column
                const crossPointY = stY + stH/2;
                const crossMidX = startX + w + 40;
                const crossMidY = startY + h/2 + 30;
                const crossEndX = startX + w + 100;
                
                group.appendChild(createEl('path', { 
                    d: `M ${crossPointX} ${crossPointY} L ${crossMidX} ${crossMidY}`, 
                    stroke:'#00FFFF', 'stroke-width':0.5, 'marker-start':'url(#arrow)' 
                }));
                group.appendChild(createEl('line', { 
                    x1: crossMidX, y1: crossMidY, x2: crossEndX, y2: crossMidY, 
                    stroke:'#00FFFF', 'stroke-width':0.5 
                }));
                const labelCross = createEl('text', { x: crossEndX + 5, y: crossMidY + 5, class: 'label-text' });
                labelCross.textContent = state.tieSize;
                group.appendChild(labelCross);
                const subLabelCross = createEl('text', { x: crossEndX + 5, y: crossMidY + 20, class: 'sub-label' });
                subLabelCross.textContent = "Crossties";
                group.appendChild(subLabelCross);
            }

            // Cover Label
            // Cover label pointing from top-left corner of concrete outline
            group.appendChild(createEl('path', { d:`M ${startX} ${startY} L ${startX-40} ${startY-30}`, stroke:'#00FFFF', 'stroke-width':0.5, 'marker-start':'url(#dot)' }));
            group.appendChild(createEl('line', { x1: startX-40, y1: startY-30, x2: startX-100, y2: startY-30, stroke:'#00FFFF', 'stroke-width':0.5 }));
            const labelCover = createEl('text', { x: startX-100, y: startY-35, class: 'sub-label' });
            labelCover.textContent = `COVER ${state.cover}mm`;
            group.appendChild(labelCover);

            // View Title Block - Column Mark, Section Name, Scale, Materials
            const titleY = startY + h + 50;
            const titleCenterX = startX + w/2;
            
            // Column Mark (from title input)
            const colMark = inputs.titleVal ? inputs.titleVal.value.toUpperCase() : 'COLUMN';
            const markText = createEl('text', { x: titleCenterX, y: titleY, 'text-anchor': 'middle', class: 'view-title' });
            markText.textContent = colMark;
            group.appendChild(markText);
            
            // Section Name
            const sectionText = createEl('text', { x: titleCenterX, y: titleY + 20, 'text-anchor': 'middle', class: 'label-text' });
            sectionText.textContent = "SECTION A-A";
            group.appendChild(sectionText);
            
            // Scale
            const scaleVal = inputs.scaleVal ? inputs.scaleVal.value : 'N.T.S.';
            const scaleText = createEl('text', { x: titleCenterX, y: titleY + 35, 'text-anchor': 'middle', class: 'sub-label' });
            scaleText.textContent = `SCALE: ${scaleVal}`;
            group.appendChild(scaleText);
            
            // Material Specifications (left side of drawing)
            const matX = startX - 30;
            const matY = startY + h + 20;
            
            const concreteVal = inputs.concrete ? inputs.concrete.value : '28 MPa';
            const steelVal = inputs.steel ? inputs.steel.value : 'SD40';
            
            const matLabel = createEl('text', { x: matX, y: matY, 'text-anchor': 'end', class: 'sub-label' });
            matLabel.textContent = `CONC: fc'=${concreteVal}`;
            group.appendChild(matLabel);
            
            const steelLabel = createEl('text', { x: matX, y: matY + 15, 'text-anchor': 'end', class: 'sub-label' });
            steelLabel.textContent = `STEEL: ${steelVal}`;
            group.appendChild(steelLabel);

            svg.appendChild(group);
        }

        function drawElevationView(isMobilePortrait = false) {
            // Mobile portrait: stack below Section A-A and center; Desktop: side by side
            const translateX = isMobilePortrait ? 150 : 700;
            const translateY = isMobilePortrait ? 600 : 0;
            const group = createEl('g', { id: 'elevation-view', transform: `translate(${translateX}, ${translateY})` });
            
            // Dynamic scaling: map actual height to visual height
            const totalHeight = state.height; // mm
            const zoneH = state.zoneHeight;   // mm
            const midH = totalHeight - 2 * zoneH;
            
            // Visual dimensions (fixed visual height for readability)
            const H = 500; 
            const W = 100;
            const startX = 100;
            const startY = 20;
            
            // Calculate visual zone heights proportionally
            const scale = H / totalHeight;
            const zHv = zoneH * scale;  // visual zone height
            const mHv = midH * scale;   // visual mid height
            
            // Parse rebar diameter from mainSize (e.g., "DB25" -> 25)
            const rebarDia = parseInt(state.mainSize.replace(/\D/g, '')) || 25;
            const lapLength = 50 * rebarDia; // 50d lap splice

            // 1. Concrete Outline
            group.appendChild(createEl('rect', { x: startX, y: startY, width: W, height: H, class: 'concrete-outline' }));
            
            // 2. Main Bars (Lines)
            group.appendChild(createEl('line', { x1: startX+15, y1: startY, x2: startX+15, y2: startY+H, stroke:'white', 'stroke-width':3 }));
            group.appendChild(createEl('line', { x1: startX+W-15, y1: startY, x2: startX+W-15, y2: startY+H, stroke:'white', 'stroke-width':3 }));
            // Center dashed axis
            group.appendChild(createEl('line', { x1: startX+W/2, y1: startY, x2: startX+W/2, y2: startY+H, stroke:'white', 'stroke-width':1, 'stroke-dasharray':'10 5', opacity:0.5 }));

            // Floor Level Markers (Left side)
            const flX = startX - 60;
            // Top Level
            group.appendChild(createEl('line', { x1: flX, y1: startY, x2: startX, y2: startY, stroke:'white', 'stroke-width':1 }));
            const flTop = createEl('text', { x: flX - 5, y: startY + 5, 'text-anchor': 'end', class: 'sub-label' });
            flTop.textContent = `FL+${(totalHeight/1000).toFixed(2)}`;
            group.appendChild(flTop);
            
            // Bottom Level
            group.appendChild(createEl('line', { x1: flX, y1: startY + H, x2: startX, y2: startY + H, stroke:'white', 'stroke-width':1 }));
            const flBot = createEl('text', { x: flX - 5, y: startY + H + 5, 'text-anchor': 'end', class: 'sub-label' });
            flBot.textContent = 'FL+0.00';
            group.appendChild(flBot);

            // Lap Splice Marker with calculated length
            const spliceY = startY + H/2 + 20;
            const splicePath = `M ${startX+15} ${spliceY} L ${startX-10} ${spliceY} L ${startX-30} ${spliceY+20}`;
            group.appendChild(createEl('path', { d: splicePath, fill:'none', stroke:'white', 'stroke-width':1 }));
            const labelSplice = createEl('text', { x: startX-35, y: spliceY+25, 'text-anchor': 'end', class: 'sub-label' });
            labelSplice.textContent = `Lap Splice 50d=${lapLength}mm`;
            group.appendChild(labelSplice);

            // 3. Stirrups Lines
            // Draw Zone Top
            const gTop = createEl('g', { stroke:'#ffeb3b', 'stroke-width':1.5 });
            const topSpacing = Math.max(8, zHv / 8); // visual spacing
            for(let y=startY+10; y < startY+zHv; y+=topSpacing) {
                gTop.appendChild(createEl('line', { x1: startX, y1: y, x2: startX+W, y2: y }));
            }
            group.appendChild(gTop);
            
            // Draw Middle
            const gMid = createEl('g', { stroke:'#ffeb3b', 'stroke-width':1.5 });
            const midSpacing = Math.max(15, mHv / 8);
            for(let y=startY+zHv+15; y < startY+H-zHv; y+=midSpacing) {
                gMid.appendChild(createEl('line', { x1: startX, y1: y, x2: startX+W, y2: y }));
            }
            group.appendChild(gMid);

            // Draw Zone Bottom
            const gBot = createEl('g', { stroke:'#ffeb3b', 'stroke-width':1.5 });
            for(let y=startY+H-zHv+10; y < startY+H; y+=topSpacing) {
                gBot.appendChild(createEl('line', { x1: startX, y1: y, x2: startX+W, y2: y }));
            }
            group.appendChild(gBot);

            // 4. Dimensions & Labels (Right side)
            const dX = startX + W + 20;
            
            // Top Zone
            group.appendChild(createEl('line', { x1: dX, y1: startY, x2: dX, y2: startY+zHv, class: 'dim-line' }));
            group.appendChild(createEl('text', { x: dX+10, y: startY + zHv/2, class:'label-text', fill:'white' })).textContent = `@${state.sZone}`;
            group.appendChild(createEl('text', { x: dX+60, y: startY + zHv/2, class:'sub-label', fill:'#aaa' })).textContent = `(${zoneH})`;

            // Mid Zone
            group.appendChild(createEl('line', { x1: dX, y1: startY+zHv, x2: dX, y2: startY+H-zHv, class: 'dim-line' }));
            group.appendChild(createEl('text', { x: dX+10, y: startY + H/2, class:'label-text', fill:'white' })).textContent = `@${state.sMid}`;
            group.appendChild(createEl('text', { x: dX+60, y: startY + H/2, class:'sub-label', fill:'#aaa' })).textContent = `(${midH})`;

            // Bot Zone
            group.appendChild(createEl('line', { x1: dX, y1: startY+H-zHv, x2: dX, y2: startY+H, class: 'dim-line' }));
            group.appendChild(createEl('text', { x: dX+10, y: startY + H - zHv/2, class:'label-text', fill:'white' })).textContent = `@${state.sZone}`;
            group.appendChild(createEl('text', { x: dX+60, y: startY + H - zHv/2, class:'sub-label', fill:'#aaa' })).textContent = `(${zoneH})`;

            // Ticks
            [startY, startY+zHv, startY+H-zHv, startY+H].forEach(y => {
                group.appendChild(createEl('line', { x1: dX-5, y1: y, x2: dX+5, y2:y, stroke:'white' }));
            });

            // Total Height Dimension (far right)
            const dX2 = dX + 110;
            group.appendChild(createEl('line', { x1: dX2, y1: startY, x2: dX2, y2: startY+H, class: 'dim-line' }));
            group.appendChild(createEl('line', { x1: dX2-5, y1: startY, x2: dX2+5, y2: startY, stroke:'white' }));
            group.appendChild(createEl('line', { x1: dX2-5, y1: startY+H, x2: dX2+5, y2: startY+H, stroke:'white' }));
            const totalLabel = createEl('text', { 
                x: dX2+10, y: startY + H/2, 
                transform: `rotate(90, ${dX2+10}, ${startY + H/2})`,
                'text-anchor': 'middle', class:'label-text', fill:'white' 
            });
            totalLabel.textContent = `TOTAL: ${totalHeight}mm`;
            group.appendChild(totalLabel);

            // View Title Block
            const titleY = startY + H + 50;
            const titleCenterX = startX + W/2;
            
            // Column Mark
            const colMark = inputs.titleVal ? inputs.titleVal.value.toUpperCase() : 'COLUMN';
            const markText = createEl('text', { x: titleCenterX, y: titleY, 'text-anchor': 'middle', class: 'view-title' });
            markText.textContent = colMark;
            group.appendChild(markText);
            
            // View Name
            const viewText = createEl('text', { x: titleCenterX, y: titleY + 20, 'text-anchor': 'middle', class: 'label-text' });
            viewText.textContent = "ELEVATION VIEW";
            group.appendChild(viewText);
            
            // Scale
            const scaleVal = inputs.scaleVal ? inputs.scaleVal.value : 'N.T.S.';
            const scaleText = createEl('text', { x: titleCenterX, y: titleY + 35, 'text-anchor': 'middle', class: 'sub-label' });
            scaleText.textContent = `SCALE: ${scaleVal}`;
            group.appendChild(scaleText);
            
            // Section Cut Lines (A-A markers)
            // Position at approximately 1/3 from top
            const cutY = startY + H * 0.3;
            const cutExtend = 40;
            
            // Left cut line with arrow
            const cutLeftX = startX - cutExtend;
            group.appendChild(createEl('line', { 
                x1: cutLeftX, y1: cutY, x2: startX, y2: cutY, 
                stroke: '#00FFFF', 'stroke-width': 1.5, 'stroke-dasharray': '8 4' 
            }));
            // Arrow pointing right (into section)
            group.appendChild(createEl('path', { 
                d: `M ${cutLeftX} ${cutY-8} L ${cutLeftX+10} ${cutY} L ${cutLeftX} ${cutY+8}`, 
                fill: '#00FFFF', stroke: 'none' 
            }));
            // A label
            const labelA1 = createEl('text', { 
                x: cutLeftX - 5, y: cutY + 5, 
                'text-anchor': 'end', class: 'label-text', fill: '#00FFFF' 
            });
            labelA1.textContent = 'A';
            group.appendChild(labelA1);
            
            // Right cut line with arrow
            const cutRightX = startX + W + cutExtend;
            group.appendChild(createEl('line', { 
                x1: startX + W, y1: cutY, x2: cutRightX, y2: cutY, 
                stroke: '#00FFFF', 'stroke-width': 1.5, 'stroke-dasharray': '8 4' 
            }));
            // Arrow pointing left (into section)
            group.appendChild(createEl('path', { 
                d: `M ${cutRightX} ${cutY-8} L ${cutRightX-10} ${cutY} L ${cutRightX} ${cutY+8}`, 
                fill: '#00FFFF', stroke: 'none' 
            }));
            // A label
            const labelA2 = createEl('text', { 
                x: cutRightX + 5, y: cutY + 5, 
                'text-anchor': 'start', class: 'label-text', fill: '#00FFFF' 
            });
            labelA2.textContent = 'A';
            group.appendChild(labelA2);

            svg.appendChild(group);
        }

        // --- Export SVG Function ---
        function exportSVG() {
            // Get the SVG element
            const svgElement = document.getElementById('main-svg');
            
            // Clone the SVG to avoid modifying the original
            const clonedSvg = svgElement.cloneNode(true);
            
            // Get computed styles for colors
            const blueprintBg = getComputedStyle(document.documentElement).getPropertyValue('--blueprint-bg').trim() || '#0a244d';
            const blueprintGrid = getComputedStyle(document.documentElement).getPropertyValue('--blueprint-grid').trim() || '#1c3b6b';
            
            // Create background and grid pattern
            // Expand viewBox for export to have room for title block at bottom-right
            const origViewBox = clonedSvg.getAttribute('viewBox').split(' ').map(Number);
            const [ovbX, ovbY, ovbW, ovbH] = origViewBox;
            
            // Expand viewBox: add margin on left for centering + width for title block on right
            const leftMargin = 100; // Shift drawings to the right
            const titleBlockWidth = 350;
            const exportVbW = ovbW + titleBlockWidth + leftMargin;
            const newVbX = ovbX - leftMargin;
            clonedSvg.setAttribute('viewBox', `${newVbX} ${ovbY} ${exportVbW} ${ovbH}`);
            
            const vbX = newVbX;
            const vbY = ovbY;
            const vbW = exportVbW;
            const vbH = ovbH;
            
            // Create defs for pattern and insert at the beginning
            let defs = clonedSvg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                clonedSvg.insertBefore(defs, clonedSvg.firstChild);
            }
            
            // Add grid pattern
            const pattern = document.createElementNS('http://www.w3.org/2000/svg', 'pattern');
            pattern.setAttribute('id', 'grid');
            pattern.setAttribute('width', '40');
            pattern.setAttribute('height', '40');
            pattern.setAttribute('patternUnits', 'userSpaceOnUse');
            
            const gridPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            gridPath.setAttribute('d', 'M 40 0 L 0 0 0 40');
            gridPath.setAttribute('fill', 'none');
            gridPath.setAttribute('stroke', blueprintGrid);
            gridPath.setAttribute('stroke-width', '1');
            pattern.appendChild(gridPath);
            defs.appendChild(pattern);
            
            // Create background rect with grid
            const bgGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            bgGroup.setAttribute('id', 'background');
            
            // Solid background
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('x', vbX - 50);
            bgRect.setAttribute('y', vbY - 50);
            bgRect.setAttribute('width', vbW + 100);
            bgRect.setAttribute('height', vbH + 100);
            bgRect.setAttribute('fill', blueprintBg);
            bgGroup.appendChild(bgRect);
            
            // Grid overlay
            const gridRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            gridRect.setAttribute('x', vbX - 50);
            gridRect.setAttribute('y', vbY - 50);
            gridRect.setAttribute('width', vbW + 100);
            gridRect.setAttribute('height', vbH + 100);
            gridRect.setAttribute('fill', 'url(#grid)');
            bgGroup.appendChild(gridRect);
            
            // Drawing Border/Frame (standard engineering drawing border)
            const borderMargin = 20;
            const borderRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            borderRect.setAttribute('x', vbX + borderMargin);
            borderRect.setAttribute('y', vbY + borderMargin);
            borderRect.setAttribute('width', vbW - 2 * borderMargin);
            borderRect.setAttribute('height', vbH - 2 * borderMargin);
            borderRect.setAttribute('fill', 'none');
            borderRect.setAttribute('stroke', 'white');
            borderRect.setAttribute('stroke-width', '3');
            bgGroup.appendChild(borderRect);
            
            // Inner drawing area border (thinner)
            const innerMargin = 30;
            const innerRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            innerRect.setAttribute('x', vbX + innerMargin);
            innerRect.setAttribute('y', vbY + innerMargin);
            innerRect.setAttribute('width', vbW - 2 * innerMargin);
            innerRect.setAttribute('height', vbH - 2 * innerMargin);
            innerRect.setAttribute('fill', 'none');
            innerRect.setAttribute('stroke', 'white');
            innerRect.setAttribute('stroke-width', '1');
            bgGroup.appendChild(innerRect);
            
            // Insert background at the beginning (after defs)
            clonedSvg.insertBefore(bgGroup, defs.nextSibling);
            
            // --- Add Title Block to SVG (at bottom-right per engineering standards) ---
            const titleBlockGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            titleBlockGroup.setAttribute('id', 'title-block');
            // Position aligned with inner border at bottom-right corner
            const tbWidth = 320;
            const tbHeight = 160;
            const tbX = vbX + vbW - innerMargin - tbWidth;  // Align with inner border right
            const tbY = vbY + vbH - innerMargin - tbHeight; // Align with inner border bottom
            titleBlockGroup.setAttribute('transform', `translate(${tbX}, ${tbY})`);
            
            // Title block background
            const tbBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            tbBg.setAttribute('x', '0');
            tbBg.setAttribute('y', '0');
            tbBg.setAttribute('width', tbWidth);
            tbBg.setAttribute('height', tbHeight);
            tbBg.setAttribute('fill', 'rgba(10, 36, 77, 0.95)');
            tbBg.setAttribute('stroke', 'white');
            tbBg.setAttribute('stroke-width', '2');
            titleBlockGroup.appendChild(tbBg);
            
            // Get values from inputs
            const projectName = inputs.project ? inputs.project.value.toUpperCase() : 'PROJECT';
            const titleVal = inputs.titleVal ? inputs.titleVal.value.toUpperCase() : '';
            const dateVal = inputs.dateVal ? inputs.dateVal.value : '';
            const drawnVal = inputs.drawnVal ? inputs.drawnVal.value : '';
            const scaleVal = inputs.scaleVal ? inputs.scaleVal.value : '';
            const noteVal = inputs.noteVal ? inputs.noteVal.value : '';
            const totalBars = 2 * state.nx + 2 * (state.ny - 2);
            
            // Project Title
            const projectText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            projectText.setAttribute('x', '15');
            projectText.setAttribute('y', '25');
            projectText.setAttribute('fill', '#ffeb3b');
            projectText.setAttribute('font-size', '14');
            projectText.setAttribute('font-weight', 'bold');
            projectText.setAttribute('font-family', 'Courier New, monospace');
            projectText.textContent = `PROJECT: ${projectName}`;
            titleBlockGroup.appendChild(projectText);
            
            // Separator line
            const sepLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            sepLine.setAttribute('x1', '10');
            sepLine.setAttribute('y1', '35');
            sepLine.setAttribute('x2', String(tbWidth - 10));
            sepLine.setAttribute('y2', '35');
            sepLine.setAttribute('stroke', 'white');
            sepLine.setAttribute('stroke-width', '1');
            titleBlockGroup.appendChild(sepLine);
            
            // Helper function for text rows
            function addTextRow(label, value, y) {
                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', '15');
                labelText.setAttribute('y', y);
                labelText.setAttribute('fill', 'white');
                labelText.setAttribute('font-size', '11');
                labelText.setAttribute('font-weight', 'bold');
                labelText.setAttribute('font-family', 'Courier New, monospace');
                labelText.textContent = label + ':';
                titleBlockGroup.appendChild(labelText);
                
                const valText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valText.setAttribute('x', '90');
                valText.setAttribute('y', y);
                valText.setAttribute('fill', 'white');
                valText.setAttribute('font-size', '11');
                valText.setAttribute('font-family', 'Courier New, monospace');
                valText.textContent = value;
                titleBlockGroup.appendChild(valText);
            }
            
            addTextRow('DWG TITLE', titleVal, 52);
            addTextRow('DATE', dateVal, 68);
            addTextRow('DRAWN BY', drawnVal, 84);
            addTextRow('SCALE', scaleVal, 100);
            addTextRow('NOTE', `${totalBars}-${state.mainSize} ${noteVal}`, 116);
            
            // Revision line at bottom of title block
            const revLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            revLine.setAttribute('x1', '0');
            revLine.setAttribute('y1', '135');
            revLine.setAttribute('x2', tbWidth);
            revLine.setAttribute('y2', '135');
            revLine.setAttribute('stroke', 'white');
            revLine.setAttribute('stroke-width', '0.5');
            titleBlockGroup.appendChild(revLine);
            
            const revText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            revText.setAttribute('x', '15');
            revText.setAttribute('y', '150');
            revText.setAttribute('fill', '#aaa');
            revText.setAttribute('font-size', '10');
            revText.setAttribute('font-family', 'Courier New, monospace');
            revText.textContent = 'REV.0 - ORIGINAL ISSUE';
            titleBlockGroup.appendChild(revText);
            
            clonedSvg.appendChild(titleBlockGroup);
            
            // --- General Notes Box (left side, above title block) ---
            const notesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            notesGroup.setAttribute('id', 'general-notes');
            const notesX = vbX + innerMargin;
            const notesY = vbY + vbH - innerMargin - 180;
            const notesWidth = 280;
            const notesHeight = 180;
            notesGroup.setAttribute('transform', `translate(${notesX}, ${notesY})`);
            
            // Notes background
            const notesBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            notesBg.setAttribute('x', '0');
            notesBg.setAttribute('y', '0');
            notesBg.setAttribute('width', notesWidth);
            notesBg.setAttribute('height', notesHeight);
            notesBg.setAttribute('fill', 'rgba(10, 36, 77, 0.9)');
            notesBg.setAttribute('stroke', 'white');
            notesBg.setAttribute('stroke-width', '1');
            notesGroup.appendChild(notesBg);
            
            // Notes title
            const notesTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            notesTitle.setAttribute('x', '10');
            notesTitle.setAttribute('y', '20');
            notesTitle.setAttribute('fill', 'white');
            notesTitle.setAttribute('font-size', '12');
            notesTitle.setAttribute('font-weight', 'bold');
            notesTitle.setAttribute('font-family', 'Courier New, monospace');
            notesTitle.textContent = 'GENERAL NOTES:';
            notesGroup.appendChild(notesTitle);
            
            // Notes content (ACI 318 terminology)
            const generalNotes = [
                "1. CONCRETE: fc'=" + (inputs.concrete ? inputs.concrete.value : '28 MPa'),
                '2. REBAR: fy=' + (inputs.steel ? inputs.steel.value : 'SD40'),
                '3. COVER TO HOOPS: ' + state.cover + 'mm',
                '4. LAP SPLICE (CLASS B): 50db MIN.',
                '5. SEISMIC HOOK: 135°, 6db EXT.',
                '6. BEND RADIUS: 4db (DB≤16), 6db (DB>16)',
                '7. CLEAR SPACING: ≥25mm OR 1.5db',
                '8. ALL DIMS IN mm UNLESS NOTED'
            ];
            
            generalNotes.forEach((note, idx) => {
                const noteText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                noteText.setAttribute('x', '10');
                noteText.setAttribute('y', 40 + idx * 17);
                noteText.setAttribute('fill', '#aaa');
                noteText.setAttribute('font-size', '10');
                noteText.setAttribute('font-family', 'Courier New, monospace');
                noteText.textContent = note;
                notesGroup.appendChild(noteText);
            });
            
            clonedSvg.appendChild(notesGroup);
            
            // Add required namespaces and styling
            clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            clonedSvg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            
            // Add embedded styles
            const styleEl = document.createElementNS('http://www.w3.org/2000/svg', 'style');
            styleEl.textContent = `
                .concrete-outline { fill: none; stroke: white; stroke-width: 2; }
                .stirrup { fill: none; stroke: #ffeb3b; stroke-width: 2; }
                .main-bar { fill: white; stroke: none; }
                .dim-line { stroke: white; stroke-width: 0.5; }
                .label-text { fill: white; font-size: 14px; font-weight: bold; font-family: 'Courier New', monospace; }
                .sub-label { fill: #aaaaaa; font-size: 12px; font-family: 'Courier New', monospace; }
                .view-title { font-size: 20px; font-weight: bold; text-decoration: underline; fill: white; font-family: 'Courier New', monospace; }
            `;
            defs.appendChild(styleEl);
            
            // Serialize to string
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(clonedSvg);
            
            // Add XML declaration
            svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;
            
            // Create download link
            const blob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            const fileName = `${inputs.titleVal ? inputs.titleVal.value.replace(/\s+/g, '_') : 'column_reinforcement'}_${new Date().toISOString().slice(0,10)}.svg`;
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Cleanup
            URL.revokeObjectURL(url);
        }

        // Start
        init();
    </script>
</body>
</html>